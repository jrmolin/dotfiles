#!/usr/bin/env bash

root=
cwd=`pwd`
cur=
full=
declare -a -g suggestions

_pcd_debug=0
_pcd_dump()
{
    if [[ 1 = $_pcd_debug ]]
    then
        echo "$@" >> $HOME/.pcd-dump.txt
    fi
}

_pcd_lstrip()
{
    echo $(echo $1 | sed -e "s/^[[:space:]]*//")
}

_pcd_strip_trailing_slash()
{
    echo $(echo $1 | sed "s|/*$||")
}

_pcd_prepend_root()
{
    local _root=$(_pcd_strip_trailing_slash $1)
    shift

    local _dirs="$@"
    local _outs=""
    local _prepend=$_root

    if [ -n "$_root" ]
    then
        _prepend="$_root/"
    else
        _prepend=""
    fi

    for i in ${!suggestions[@]}
    do
        _pcd_dump "_pcd_prepend_root :: ${suggestions[$i]}"
        suggestions[$i]="${_prepend}${suggestions[$i]}"
    done
}

_pcd_get_subdirs()
{
    # get rid of the trailing slash
    local _root=$(_pcd_strip_trailing_slash $1)

    # dump the root
    _pcd_dump "_pcd_get_subdirs() root: $_root"

    # find the root
    local _dirs=($(command find $_root -maxdepth 1 -type d | sort ))
    local _out=""
    _pcd_dump "suggestions: [${suggestions[@]}]"
    for i in ${_dirs[@]}
    do
        if [[ "$i" = "$_root" ]]
        then
            continue
        fi

        i=${i#$_root/}

        #_pcd_dump "dir $i"
        suggestions+=($i)
    done
    _pcd_dump "suggestions: [${suggestions[@]}]"
}

_pcd_get_dirs()
{
    local _base=$1

    _pcd_dump "_pcd_get_dirs base[$_base] cur[$cur]"
    # if nothing has been added, just get the subdirectories under the root
    if [ -z "$cur" ]
    then
        _pcd_get_subdirs "$_base"
        cur=
        full=

    # if the user passed in a full sub-directory, create suggestions based on that
    elif [ -d "$_base/$cur" ]
    then
        _pcd_get_subdirs "$_base/$cur"
        #_pcd_prepend_root "$_base/$cur"
        full=$cur
        cur=""
    else

        # handle partial directories here

        # split the current path by separator
        local _path=($(echo $cur | tr '/' ' '))

        # get the last directory (could be partial) in the path
        last=${_path[-1]}
        _pcd_dump "path: $cur :: ${_path[@]} :: $last"
        local full_cur=""

        # remove the last directory (could be partial)
        full_cur=${cur::-${#last}}

        _pcd_dump "full-cur: [$full_cur]"

        # if we have a valid sub, add it to the base
        local _tmpBase=$(_pcd_strip_trailing_slash "$_base/$full_cur")

        _pcd_get_subdirs "$_tmpBase"
        #_pcd_prepend_root "$_full_cur"
        cur=$last
        full=$full_cur
    fi

}

#
# -- find the project root
# -- if the user has entered some text, figure out if there is a valid path in there
# -- if there is a valid path (and no more), create proper suggestions
#
#
_pcd()
{
    suggestions=()
    root=
    cwd=`pwd`
    cur=
    full=

    _pcd_dump "${#COMP_WORDS[@]}"
    if [[ "${#COMP_WORDS[@]}" > 2 ]]
    then
        return
    fi

    cur=${COMP_WORDS[COMP_CWORD]}
    local _prev=${COMP_WORDS[1]}

    _pcd_dump "cur: [$cur]; prev: [$_prev]"

    local _root=$(projectRoot .git 1)
    _pcd_get_dirs $_root

    _pcd_dump "_pcd: suggestions: [${suggestions[@]}] cur:[$cur]"

    local outs=""
    if [[ ${#suggestions} > 0 ]]
    then
        for i in ${suggestions[@]}
        do
            outs="$outs $i"
        done
    fi

    # now i have all the base directories
    suggestions=($(compgen -W "$outs" -- "$cur"))
    _pcd_dump "_pcd() suggestions: [${suggestions[@]}] -- cur [$cur] -- full [$full]"

    if [[ 1 == ${#suggestions[@]} ]]
    then
        _pcd_prepend_root $full
        _pcd_dump "_pcd() suggestions: [${suggestions[@]}]"
        COMPREPLY=("${suggestions[0]}/")
    else
        COMPREPLY=(${suggestions[@]})
    fi
    return 0

}

function pcd()
{
    local meh=$(projectRoot .git 1)

    cd "$meh/$1"
}

complete -o nospace -F _pcd pcd

